var format = require('util').format;
var debug = require('debug')('appreports:app');
var mongoose = require('mongoose');
var Schema = mongoose.Schema;
var async = require('async');

var nowAsDate = require('app/date').nowAsDate;
var todayAsString = require('app/date').todayAsString;
var todayAsNumber = require('app/date').todayAsNumber;
var convertDateString = require('app/date').convertDateString;
var getAge = require('app/date').getAge;
var getAgeHuman = require('app/date').getAgeHuman;
var regions = require('app/regions');
var crawler = require('app/crawler');

var AppSummary = require('models/app-summary');
var AuditLog = require('models/audit-log');
var AppLink = require('models/app-link');
var AppRating = require('models/app-rating');

var schema = new Schema({
	storeId: String,
  datePublished: Number,
  lastUpdated: Number,
  softwareVersion: String,
  name: String,
  description: String,
  notes: String,
  image: String,
  primaryUrl: String,
  bitly: String,
  formatUrl: String,
  platform: String,
  baseline: Number,
  status: String,
  includeAppRatings: { type: Boolean, default: false }
}, { autoIndex: process.env.MONGO_AUTOINDEX || false });

schema.methods.getAge = function() {
  return getAge(this.lastUpdated);
}

schema.methods.getAgeHuman = function() {
  return getAgeHuman(this.lastUpdated);
}

schema.methods.getLastUpdatedDate = function() {
  return convertDateString(this.lastUpdated, 'YYYYMMDD', 'YYYY-MM-DD');
}

schema.methods.getDatePublished = function() {
  return convertDateString(this.datePublished, 'YYYYMMDD', 'YYYY-MM-DD');
}

schema.methods.rollUp = function(options, done) {
  if(typeof options === 'function') {
    done = options;

    options = {
      dayLimit: 3
    };
  }

  AppRating.distinct('date', { storeId: this.storeId }, function(err, dates) {
    dates.sort(function(a, b) {
      return a - b;
    });

    var dayLimit = options.dayLimit || 3;

    if(dayLimit > 0) {
      dates = dates.slice(-dayLimit);
    }

    var previous = null;
    async.eachSeries(dates, function(date, nextDate) {
      debug('rolling up', this.name, date);
      var data = { storeId: this.storeId, date: date };
      AppSummary.findOne(data, function(err, summary) {
        if(!summary) {
          summary = new AppSummary(data);
        }

        if(summary.finalized) {
          return nextDate();
        }

        summary.name = this.name;
        summary.image = this.image;
        summary.primaryUrl = this.primaryUrl;
        summary.platform = this.platform;

        AppRating.find(
          { storeId: summary.storeId, date: date, ratingCount: { $gt: 0 }},
          { region: 1, ratingCount: 1, ratingAverage: 1, reviewOnly: 1 },
          function(err, ratings) {
          var worldTotal = worldCount = 0;
          async.each(ratings, function(rating, nextRating) {
            if(rating.region == 'en-us') {
              summary.usaRatings = rating.ratingCount;
              summary.usaAverage = Math.floor(rating.ratingAverage * 10) / 10;
            }

            if(!rating.reviewOnly) {
              worldCount += rating.ratingCount;
              worldTotal += rating.ratingCount * rating.ratingAverage;
            }

            nextRating();
          }, function(err) {
            summary.worldRatings = worldCount;
            summary.worldAverage = Math.floor(worldTotal / worldCount * 10) / 10;
            summary.usaRatingsChange = 0;
            summary.usaAverageChange = 0;
            summary.worldRatingsChange = 0;
            summary.worldAverageChange = 0;

            if(previous) {
              summary.usaRatingsChange = summary.usaRatings - previous.usaRatings;
              summary.usaAverageChange = Math.floor((summary.usaAverage - previous.usaAverage) * 10) / 10;
              summary.worldRatingsChange = summary.worldRatings - previous.worldRatings;
              summary.worldAverageChange = Math.floor((summary.worldAverage - previous.worldAverage) * 10) / 10;
            }

            summary.save(function() {
              previous = summary;
              nextDate();
            });
          });
        }.bind(this));
      }.bind(this));
    }.bind(this), done);
  }.bind(this));
}

schema.methods.updateAppDetails = function(done) {
  if(!done) {
    done = function() {};
  }

  crawler.fetchAppDetails(this.primaryUrl, function(err, details) {
    var updateLastUpdated = false;

    if(details.name && details.name != this.name) {
      AuditLog.addLog({
        storeId: this.storeId,
        field: 'name',
        oldValue: this.name,
        newValue: details.name
      });
      this.name = details.name;
    }

    if(details.softwareVersion && details.softwareVersion != this.softwareVersion) {
      AuditLog.addLog({
        storeId: this.storeId,
        field: 'softwareVersion',
        oldValue: this.softwareVersion,
        newValue: details.softwareVersion
      });

      this.softwareVersion = details.softwareVersion;
    }

    if(details.datePublished && details.datePublished != this.datePublished) {
      AuditLog.addLog({
        storeId: this.storeId,
        field: 'datePublished',
        oldValue: this.datePublished,
        newValue: details.datePublished
      });

      this.datePublished = details.datePublished;
    }


    if(details.description && details.description != this.description) {
      if(this.platform === 'client') {
        /*
          The description has been updated on a Windows Client app. Since the
          store doesn't provide the publish date, we assume the app has been
          updated since the description has.

          TODO: Fix this once the store makes the publish date available
        */
        updateLastUpdated = true;
      }

      AuditLog.addLog({
        storeId: this.storeId,
        field: 'description',
        oldValue: this.description,
        newValue: details.description
      });

      this.description = details.description;
    }


    if(details.notes && details.notes != this.notes) {
      if(this.platform === 'client') {
        /*
          The notes have been updated on a Windows Client app. Since the
          store doesn't provide the publish date, we assume the app has been
          updated since the description has.

          TODO: Fix this once the store makes the publish date available
        */
        updateLastUpdated = true;
      }

      AuditLog.addLog({
        storeId: this.storeId,
        field: 'notes',
        oldValue: this.notes,
        newValue: details.notes
      });

      this.notes = details.notes;
    }

    if(updateLastUpdated && this.lastUpdated && !details.lastUpdated) {
      debug('Overriding lastUpdated');
      details.lastUpdated = todayAsNumber();
    }

    if(details.lastUpdated && details.lastUpdated != this.lastUpdated) {
      AuditLog.addLog({
        storeId: this.storeId,
        field: 'lastUpdated',
        oldValue: this.lastUpdated,
        newValue: details.lastUpdated
      });

      this.lastUpdated = details.lastUpdated;
    }

    if(details.status && details.status != this.status) {
      AuditLog.addLog({
        storeId: this.storeId,
        field: 'status',
        oldValue: this.status,
        newValue: details.status
      });

      this.status = details.status;
    }


    if(this.isModified()) {
      debug('updating app details', this.modifiedPaths());
      this.save();
    }

    done();
  }.bind(this));
}

schema.methods.findStoreRegions = function(done) {
  this.updateAppDetails();

  async.eachLimit(Object.keys(regions), 20, function(region, nextRegion) {
    var url = this.getUrl(region);
    var reviewOnly = regions[region].reviewOnly || false;

    crawler.getStatus(url, function(status) {
      var data = {
        storeId: this.storeId,
        region: region
      };

      AppLink.findOne(data, function(err, doc) {
        if(!doc) {
          doc = new AppLink(data);
        }

        if(doc.status != status) {
          AuditLog.addLog({
            storeId: this.storeId,
            region: region,
            field: 'status',
            oldValue: doc.status,
            newValue: status
          });

          debug(url, doc.status + ' => ' + status);
        }

        doc.status = status;
        doc.name = this.name;
        doc.reviewOnly = reviewOnly;
        doc.processedAt = nowAsDate();
        doc.platform = this.platform;
        doc.primaryUrl = this.primaryUrl;
        doc.url = url;
        doc.bitly = this.bitly;
        doc.baseline = this.baseline;

        doc.save(nextRegion);
      }.bind(this));
    }.bind(this));
  }.bind(this), done);
};

schema.methods.parseUrl = function(url) {
	if(url.indexOf('windowsphone.com') > 0) {
		this.platform = 'phone';
  } else {
  	this.platform = 'client';
  }

  this.storeId = url.substr(url.length - 36);
  this.primaryUrl = url;
  this.formatUrl = url.replace('en-us', '%s');
}

schema.methods.getUrl = function(region) {
	return format(this.formatUrl, region);
};

schema.statics.getDetails = function(storeId, date, done) {
  if(typeof done !== 'function') {
    throw 'must supply getDetails callback';
  }

  if(!date) {
    date = todayAsNumber();
  }

  date = date * 1;

  this.findOne({ storeId: storeId }, function(err, app) {
    AppRating.getDetails(storeId, date, function(err, regions) {
      done(err, app, regions);
    });
  });
}

schema.statics.getStaleAppSummary = function(done) {
  var staleAppSummary = {
    deadApps: [],
    dangerApps: [],
    warningApps: [],
    freshApps: []
  };

  var today = todayAsNumber();

  this.each(function(app, nextApp) {
    if(app.status == 301) {
      staleAppSummary.deadApps.push(app);
      return nextApp();
    }

    if(!app.lastUpdated) {
      return nextApp();
    }

    var age = app.getAge();

    if(age > 365) {
      staleAppSummary.dangerApps.push(app);
      return nextApp();
    }

    if(age > 182) {
      staleAppSummary.warningApps.push(app);
      return nextApp();
    }

    if(age <= 7) {
      staleAppSummary.freshApps.push(app);
      return nextApp();
    }

    return nextApp();
  }, function(err) {
    done(err, staleAppSummary);
  });
}

schema.statics.updateApps = function(done) {
  this.each(function(app, nextApp) {
    app.updateAppDetails(nextApp);
  }, done);
};

schema.statics.findStoreRegions = function(done) {
  this.each(function(app, nextApp) {
    app.findStoreRegions(nextApp);
  }, done);
};

schema.statics.rollUpApps = function(done) {
  this.each(function(app, nextApp) {
    app.rollUp(nextApp);
  }, done);
};

schema.statics.each = function(iterator, done) {
  this.find().sort({lastUpdated: 1}).exec(function(err, apps) {
    async.eachSeries(apps, iterator, done);
  });
};

schema.statics.createFromData = function(data, done) {
  this.findOne({ primaryUrl: data.primaryUrl }, function(err, app) {
    if(!app) {
      app = new App(data);
    }

    app.datePublished = data.datePublished;
    app.lastUpdated = data.lastUpdated;
    app.includeAppRatings = false;
    app.parseUrl(app.primaryUrl);

    app.save(function() {
      app.updateAppDetails(done);
    });

  });
}

var App = module.exports = mongoose.model('App', schema);
