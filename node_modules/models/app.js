var format = require('util').format;
var debug = require('debug')('appreports:app');
var mongoose = require('mongoose');
var Schema = mongoose.Schema;
var async = require('async');

var nowAsDate = require('app/date').nowAsDate;
var regions = require('app/regions');
var crawler = require('app/crawler');

var AppSummary = require('models/app-summary');
var AuditLog = require('models/audit-log');
var AppLink = require('models/app-link');
var AppRating = require('models/app-rating');

var schema = new Schema({
	storeId: String,
  datePublished: String,
  softwareVersion: String,
  name: String,
  image: String,
  primaryUrl: String,
  bitly: String,
  formatUrl: String,
  platform: String,
  baseline: Number
});

schema.methods.rollUp = function(done) {
  AppRating.distinct('date', { storeId: this.storeId }, function(err, dates) {
    dates.sort(function(a, b) {
      return a - b;
    });

    var previous = null;
    async.eachSeries(dates, function(date, nextDate) {
      debug('rolling up', this.name, date);
      var data = { storeId: this.storeId, date: date };
      AppSummary.findOne(data, function(err, summary) {
        if(!summary) {
          summary = new AppSummary(data);
        }

        if(summary.finalized) {
          return nextDate();
        }

        summary.name = this.name;
        summary.image = this.image;
        summary.primaryUrl = this.primaryUrl;
        summary.platform = this.platform;

        AppRating.find(
          { storeId: summary.storeId, date: date, ratingCount: { $gt: 0 }},
          { region: 1, ratingCount: 1, ratingAverage: 1 },
          function(err, ratings) {
          var worldTotal = worldCount = 0;
          async.each(ratings, function(rating, nextRating) {
            if(rating.region == 'en-us') {
              summary.usaRatings = rating.ratingCount;
              summary.usaAverage = Math.floor(rating.ratingAverage * 10) / 10;
            }

            worldCount += rating.ratingCount;
            worldTotal += rating.ratingCount * rating.ratingAverage;

            nextRating();
          }, function(err) {
            summary.worldRatings = worldCount;
            summary.worldAverage = Math.floor(worldTotal / worldCount * 10) / 10;
            summary.usaRatingsChange = 0;
            summary.usaAverageChange = 0;
            summary.worldRatingsChange = 0;
            summary.worldAverageChange = 0;

            if(previous) {
              summary.usaRatingsChange = summary.usaRatings - previous.usaRatings;
              summary.usaAverageChange = Math.floor((summary.usaAverage - previous.usaAverage) * 10) / 10;
              summary.worldRatingsChange = summary.worldRatings - previous.worldRatings;
              summary.worldAverageChange = Math.floor((summary.worldAverage - previous.worldAverage) * 10) / 10;
            }

            summary.save(function() {
              previous = summary;
              nextDate();
            });
          });
        }.bind(this));
      }.bind(this));
    }.bind(this), done);
  }.bind(this));
}

schema.methods.addAudit = function(auditData, done) {
  AuditLog.addLog({
    storeId: this.storeId,
    data: auditData
  }, done);
}

schema.methods.updateAppDetails = function() {
  crawler.fetchAppDetails(this.primaryUrl, function(err, details) {
    var audit = {};
    var changed = false;

    if(details.name && details.name != this.name) {
      changed = true;
      audit.oldName = this.name;
      audit.newName = details.name;
      this.name = details.name;
    }

    if(details.softwareVersion && details.softwareVersion != this.softwareVersion) {
      changed = true;
      audit.oldSoftwareVersion = this.softwareVersion;
      audit.newSoftwareVersion = details.softwareVersion;
      this.softwareVersion = details.softwareVersion;
    }

    if(details.datePublished && details.datePublished != this.datePublished) {
      changed = true;
      audit.oldDatePublished = this.datePublished;
      audit.newDatePublished = details.datePublished;
      this.datePublished = details.datePublished;
    }

    if(changed) {
      debug('updating app details', this);
      this.save();
      this.addAudit(audit);
    }
  }.bind(this));
}

schema.methods.findStoreRegions = function(done) {
  this.updateAppDetails();

  async.eachLimit(Object.keys(regions), 20, function(region, nextRegion) {
    var url = this.getUrl(region);
    crawler.getStatus(url, function(status) {
      var data = {
        storeId: this.storeId,
        region: region
      };

      AppLink.findOne(data, function(err, doc) {
        if(!doc) {
          doc = new AppLink(data);
        }

        if(doc.status != status) {
          var audit = {
            region: region,
            oldStatus: doc.status,
            newStatus: status
          };

          doc.addAudit(audit);

          debug(url, doc.status + ' => ' + status);
        }

        doc.status = status;
        doc.name = this.name;
        doc.processedAt = nowAsDate();
        doc.platform = this.platform;
        doc.primaryUrl = this.primaryUrl;
        doc.url = url;
        doc.bitly = this.bitly;
        doc.baseline = this.baseline;

        doc.save(nextRegion);
      }.bind(this));
    }.bind(this));
  }.bind(this), done);
};

schema.methods.parseUrl = function(url) {
	if(url.indexOf('windowsphone.com') > 0) {
		this.platform = 'phone';
  } else {
  	this.platform = 'client';
  }

  this.storeId = url.substr(url.length - 36);
  this.primaryUrl = url;
  this.formatUrl = url.replace('en-us', '%s');
}

schema.methods.getUrl = function(region) {
	return format(this.formatUrl, region);
};

schema.statics.findStoreRegions = function(done) {
  this.each(function(app, nextApp) {
    app.findStoreRegions(nextApp);
  }, done);
};

schema.statics.rollUpApps = function(done) {
  this.each(function(app, nextApp) {
    app.rollUp(nextApp);
  }, done);
};

schema.statics.each = function(iterator, done) {
  this.find().exec(function(err, apps) {
    async.eachSeries(apps, iterator, done);
  });
};

module.exports = mongoose.model('App', schema);
